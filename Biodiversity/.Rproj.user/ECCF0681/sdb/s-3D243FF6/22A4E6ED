{
    "contents" : "# To DO:\n#   1. mask out land area from the analysis\n\n\n\n#This section for optional additional work with R\nlibrary(rgdal)\nlibrary(dismo)\nlibrary(rJava)\nlibrary(maptools)\n\nsetwd(\"~/GitHub/Biodiversity\")\n#load land shapefile\nland<- readShapePoly('land.shp')\n#Read point files\nDornpts<-readShapePoints(\"Dornelas_terrt.shp\")\n\n# read arcgis rasters directly\nrnorm <- raster(\"marineAllNorm.tif\") #normalized for each taxon then averaged for \"mean diversity\"\nr<- raster(\"marineBiodivAll.tif\") #all taxa\n\n#examine the distribution of pixel values\nh <- hist(r, breaks = 5, plot=FALSE)\nh$counts=h$counts/sum(h$counts)\nplot(h)\nq<- quantile(r) \n\n# reclassify to categories or actual values?\n#m <- c(0,4,1,4,9,2,9,18,3,18,64,4)\nmat    <- c(0,0,NA, 0.01,64,1, 64,104,2,  104,310,3, 310,3410, 4) #0 to NA for use in mask later\nrclmat <- matrix(mat,ncol=3,byrow=TRUE)\nrq <- reclassify(r, rclmat)\n\n\n\n# kfold sampling for training and testing\nfold <- kfold(Dornpts, k=3) #best practices for #?\nptstest <- Dornpts[fold == 1, ] #one subsample for validation\nptstrain <- Dornpts[fold != 1, ] #the rest of the subsamples for model training\npoints(ptstest, col=\"blue\")\n\n# Option 2: do a balanced random sample instead\nAtoNA <- c(0, NA, 1, 1)\nPtoNA <- c(0, 1, 1, NA)\nPmat <- matrix(AtoNA,ncol=2,byrow=TRUE)\nAmat <- matrix(PtoNA,ncol=2,byrow=TRUE)\npmask <- reclassify(r,Pmat)\namask <- reclassify(r,Amat)\nprespts <- randomPoints(pmask, 300)  \nabspts <- randomPoints(amask, 300)\nplot(r)\npoints(prespts, col=\"blue\")\npoints(abspts, col=\"red\")\npts <- rbind(prespts,abspts)\n############## MY EDIT OF ABOVE:  NOT WORKING, STILL 0 not NA in rmask/rand pts on land.\nrmask<- reclassify(r, rclmat)\nrandoPts<- randomPoints(rmask, 300)\nplot(r)\npoints(Dornpts, col='blue')\npoints(randoPts, col='red')\n\n\n\n\n\n#extract dependent and predictor values from rasters for training and testing\ndorntrain <- cbind(ptstrain,extract(r, ptstrain))\ncolnames(patrain)[3] <- \"oakb\"\npatrain <- cbind(patrain, extract(s, ptstrain))\npatrain <- data.frame(patrain[complete.cases(patrain),])\n\npatest <- cbind(ptstest,extract(r, ptstest))\ncolnames(patest)[3] <- \"oakb\"\npatest <- cbind(patest, extract(s, ptstest))\npatest <- data.frame(patest[complete.cases(patest),])\n\n#GLM\nglm <- glm(oakb~dem+sandp+coarse+slope+topowet, family=binomial,data=patrain)\nresponse(glm)\nsummary(glm)\nanova(glm)\n\n#make within- and outside-sample prediction for GLM\nlYhattrain <- predict(glm, newdata=patrain) #calculate probabilities training data\nlYhattest <- predict(glm, newdata=patest) #calculate probabilities testing data\n\n#make prediction raster from GLM\nsdf <- data.frame(getValues(s))\npredict <- predict(glm, newdata=sdf)\np = raster(nrows=nrow(s), ncols=ncol(s), ext=extent(s), vals=predict)\nplot(p)\n\n#GAM\ngam <- gam(oakb~s(sandp)+s(dem)+s(topowet)+s(slope)+coarse, family=binomial, data=patrain)\nsummary(gam)\nplot(gam, se=TRUE)\nanova(gam)      #test for non-linearity in effects\n\n#make within- and outside-sample predictions with GAM\nYhattest <- predict(gam, newdata=patest)       #predict odds\nlYhattest <- exp(Yhattest) / (1 + exp(Yhattest))  #logit transformation\n\nYhattrain <- predict(gam, newdata=patrain)       #predict odds\nlYhattrain <- exp(Yhattrain) / (1 + exp(Yhattrain))  #logit transformation\n\n#neural net\nann <- nnet(oakb~sandp+dem+topowet+slope+coarse, patrain, patrain$oakb, 10, rang=0.1)\nprint(ann)\nsummary(ann)\n\n#make within- and outside-sample predictions with ANN\nlYhattrain <- predict(ann, patrain, type=\"raw\") #calculate probabilities training data\nlYhattest <- predict(ann, patest) #calculate probabilities testing data\n\n# MaxEnt - Create presence-only data\npa <- cbind(pts,extract(r, pts))\ncolnames(pa)[3] <- \"oakb\"\npa <- subset(pa, pa[,3]==1)\nocc <- pa\nocc[,3] <- NULL\nplot(r)\npoints(occ)\nsme <- dropLayer(s, 2)\nsme <- dropLayer(sme, 3)\n\n#MaxEnt model\nme <- maxent(sme, occ)\nplot(me)\nresponse(me)\nshow(me)\n\n# choose a threshold for dichotomizing according to predicted probability\nthresh <- 0.5\nYhatFac <- cut(lYhattrain, breaks=c(-Inf, thresh, Inf), labels=c(\"lo\", \"hi\"))\n# contingency table and marginal sums\ncTab <- table(patrain$oakb, YhatFac)\naddmargins(cTab)\n# percentage correct for training data\nsum(diag(cTab)) / sum(cTab)\n\n#ROC\nROC <- roc(patest$oakb, lYhattest)\nplot.roc(ROC)\n\n#make prediction raster from GAM\nsdf <- data.frame(getValues(s))\npredict <- predict(gam, newdata=sdf)\np = raster(nrows=nrow(s), ncols=ncol(s), ext=extent(s), vals=predict)\nlp = exp(p) / (1 + exp(p))\nplot(lp)\n\n#make prediction raster from MaxEnt\np <- predict(me, s)\nplot(p)\n\n#ROC for maxent\npaxy <- cbind(pa$x, pa$y)\npa <- cbind(pa, extract(p, paxy))\ncolnames(pa)[4] <- \"pred\"\npa <- data.frame(pa[complete.cases(pa),])\n\nROC <- roc(pa$oakb, pa$pred)\nplot.roc(ROC)\n\n#MCE DATA SET\n#read layers from MCE lab\nsetwd(\"h:/projects/nre534/mce/4R\")\ns <- stack(\"annarbor\", \"clayp\", \"elevation\", \"lu95\", \"public\", \"roads\", \"sandp\", \"stream\", \"veg_1850\")\nplot(s)\n\n#calculate distances\nzerotoNA <- c(0, NA, 1, 1)\nrclmat <- matrix(zerotoNA,ncol=2,byrow=TRUE)\n\ns$rddist <- distance(reclassify(s$roads,rclmat))\ns$strdist <- distance(reclassify(s$stream, rclmat))\ns$aadist <- distance(reclassify(s$annarbor, rclmat))\ns$slope <- terrain(s$elevation, unit='degrees')\n\nplot(s) \n\nlu2dev <- c(110,139,1,140,625,0) # reclass dev,  minus trans, extraction, cemetaries\nlumat <- matrix(lu2dev,ncol=3,byrow=TRUE)\n\nd <- reclassify(s$lu95, lumat)\n\n\n#sample\nd2 <- aggregate(d, 20)\npts <- as.data.frame(d2, xy=TRUE)\npts$layer <- NULL\nplot(d)\npoints(pts, col='red')\n\n",
    "created" : 1430146127044.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2865559726",
    "id" : "22A4E6ED",
    "lastKnownWriteTime" : 1430166972,
    "path" : "~/GitHub/Biodiversity/representativeness.R",
    "project_path" : "representativeness.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}